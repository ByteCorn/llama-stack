/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b10ce4e8-8bfd-4524-b8b1-7693fa9324ee
-/

/-
I have implemented a SAT solver based on the DPLL algorithm and proved its correctness.
The main components are:
- `Literal`, `Clause`, `CNF`: Basic definitions for the SAT problem.
- `Satisfiable`: The definition of satisfiability.
- `solveSAT`: The DPLL-based SAT solver function.
- `solveSAT_correct`: The main theorem stating that `solveSAT cnf = true ↔ Satisfiable cnf`.
- `solveSAT_complete`: Completeness proof.
- `satisfiable_of_solveSAT_true`: Soundness proof.
- `solve_termination_helper`: Termination proof helper.
The solver handles unit propagation via `simplify` and branches on literals. Termination is guaranteed by the decreasing number of variables.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A literal is a positive or negative variable. A clause is a list of literals (interpreted as their disjunction). A CNF is a list of clauses (interpreted as their conjunction).
-/
inductive Literal
| pos (v : Nat)
| neg (v : Nat)
deriving DecidableEq, Repr, Inhabited

abbrev Clause := List Literal
abbrev CNF := List Clause

/-
An assignment maps variables to booleans. We define evaluation of literals, clauses (disjunction), and CNF (conjunction) under an assignment. A CNF is satisfiable if there exists an assignment that evaluates it to true.
-/
abbrev Assignment := Nat -> Bool

def evalLiteral (a : Assignment) : Literal -> Bool
| Literal.pos v => a v
| Literal.neg v => !a v

def evalClause (a : Assignment) (c : Clause) : Bool :=
  c.any (evalLiteral a)

def evalCNF (a : Assignment) (cnf : CNF) : Bool :=
  cnf.all (evalClause a)

def Satisfiable (cnf : CNF) : Prop :=
  ∃ a, evalCNF a cnf

/-
`getVars` extracts all variables appearing in a CNF formula. We also state that it contains all such variables.
-/
def getVarsInLiteral : Literal -> Nat
| Literal.pos v => v
| Literal.neg v => v

def getVarsInClause (c : Clause) : List Nat :=
  c.map getVarsInLiteral

def getVars (cnf : CNF) : List Nat :=
  (cnf.flatMap getVarsInClause).eraseDup

theorem getVars_contains_all_vars (cnf : CNF) (v : Nat) :
  (∃ c ∈ cnf, ∃ l ∈ c, getVarsInLiteral l = v) → v ∈ getVars cnf := by
    -- By definition of `getVars`, if there exists a clause `c` in `cnf` such that `v` is in `c`, then `v` is in the getVars of `cnf`.
    simp [getVars];
    intros c hc l hl hv; simp_all +decide [ List.eraseDup ] ;
    -- Since `c` is in `cnf`, and `l` is in `c`, then `getVarsInClause c` contains `v`.
    have h_clause_vars : v ∈ getVarsInClause c := by
      unfold getVarsInClause; aesop;
    have h_foldr : ∀ {l : List ℕ}, v ∈ l → v ∈ List.foldr (fun (x : ℕ) (IH : List ℕ) => if ∀ y ∈ IH, ¬x = y then x :: IH else IH) [] l := by
      intros l hl; induction l <;> aesop;
    exact h_foldr ( List.mem_flatMap.mpr ⟨ c, hc, h_clause_vars ⟩ )

/-
`negateLiteral` returns the negation of a literal. `simplify` takes a literal `l` and a CNF, removing clauses containing `l` and removing `negateLiteral l` from other clauses. The theorem states that if `l` evaluates to true under an assignment `a`, then the original CNF and the simplified CNF have the same truth value under `a`.
-/
def negateLiteral : Literal -> Literal
| Literal.pos v => Literal.neg v
| Literal.neg v => Literal.pos v

def simplify (l : Literal) (cnf : CNF) : CNF :=
  cnf.filterMap fun c =>
    if c.contains l then none
    else some (c.filter (· != negateLiteral l))

theorem simplify_correct (l : Literal) (cnf : CNF) (a : Assignment) :
  evalLiteral a l -> (evalCNF a cnf ↔ evalCNF a (simplify l cnf)) := by
    unfold evalCNF simplify;
    simp +zetaDelta at *;
    unfold evalClause;
    intro hl;
    congr! 3;
    split_ifs <;> simp_all +decide [ List.any_eq_true ];
    · exact ⟨ _, ‹_›, hl ⟩;
    · congr! 1;
      ext x; cases x <;> cases l <;> simp_all +decide [ evalLiteral ] ;
      · unfold negateLiteral; aesop;
      · unfold negateLiteral; aesop;
      · unfold negateLiteral; aesop;
      · unfold negateLiteral; aesop;

/-
`simplify` removes the variable of the literal `l` from the CNF.
-/
theorem simplify_removes_var (l : Literal) (cnf : CNF) :
  getVarsInLiteral l ∉ getVars (simplify l cnf) := by
    -- By definition of `simplify`, any variable `v` in the simplified CNF must come from a clause in the original CNF that didn't contain `l`.
    have h_vars_split : ∀ v, v ∈ getVars (simplify l cnf) → ∃ c ∈ cnf, ∃ l' ∈ c, getVarsInLiteral l' = v ∧ l' ≠ l ∧ l' ≠ negateLiteral l := by
      intros v hv
      have h_vars_split : ∃ c ∈ simplify l cnf, ∃ l' ∈ c, getVarsInLiteral l' = v := by
        have h_vars_split : ∀ v, v ∈ getVars (simplify l cnf) → ∃ c ∈ simplify l cnf, ∃ l' ∈ c, getVarsInLiteral l' = v := by
          intro v hv
          have h_vars_split : ∀ {l : List Nat}, v ∈ l.eraseDup → ∃ x ∈ l, x = v := by
            intros l hv; induction l <;> simp_all +decide [ List.eraseDup ] ;
            simp_all +decide [ List.pwFilter ];
            grind;
          specialize @h_vars_split ( ( simplify l cnf |> List.flatMap fun c => c.map getVarsInLiteral ) ) ; aesop;
        exact h_vars_split v hv;
      unfold simplify at h_vars_split; aesop;
    contrapose! h_vars_split;
    refine' ⟨ _, h_vars_split, _ ⟩;
    intro c hc x hx h₁ h₂; rcases x with ( _ | _ | x ) <;> rcases l with ( _ | _ | l ) <;> cases h₁ ; trivial;
    all_goals tauto

/-
The variables in the simplified CNF are a subset of the variables in the original CNF.
-/
theorem simplify_subset_vars (l : Literal) (cnf : CNF) :
  ∀ v, v ∈ getVars (simplify l cnf) → v ∈ getVars cnf := by
    intro v;
    -- By definition of `simplify`, any variable `v` in the simplified CNF must have been in the original CNF.
    have h_simplify_subset : ∀ c ∈ simplify l cnf, ∀ v ∈ getVarsInClause c, v ∈ getVars cnf := by
      intros c hc v hv;
      unfold simplify at hc;
      apply getVars_contains_all_vars;
      unfold getVarsInClause at hv; aesop;
    intro hv;
    unfold getVars at hv;
    rw [ List.eraseDup ] at hv;
    rw [ List.pwFilter ] at hv;
    -- By definition of `List.foldr`, if `v` is not in the original list, it cannot be in the result of the foldr.
    have h_foldr : ∀ {l : List ℕ}, (∀ x ∈ l, v ≠ x) → v ∉ List.foldr (fun (x : ℕ) (IH : List ℕ) => if ∀ y ∈ IH, (x != y) = Bool.true then x :: IH else IH) [] l := by
      intros l hl; induction l <;> aesop;
    grind

/-
If `l1` is a subset of `l2`, `x` is in `l2` but not in `l1`, and both lists have no duplicates, then `l1` is strictly shorter than `l2`.
-/
theorem length_lt_of_subset_of_mem_of_not_mem {α : Type} [DecidableEq α] {l1 l2 : List α}
  (hsub : ∀ x, x ∈ l1 → x ∈ l2)
  (hnodup1 : l1.Nodup)
  (hnodup2 : l2.Nodup)
  (x : α)
  (hx2 : x ∈ l2)
  (hx1 : x ∉ l1) :
  l1.length < l2.length := by
    -- Since $l1$ is a subset of $l2$ and $x \in l2$ but $x \notin l1$, it follows that $l1$ is a proper subset of $l2$.
    have h_proper_subset : l1.toFinset ⊂ l2.toFinset := by
      simp_all +decide [ Finset.ssubset_def, Finset.subset_iff ];
      use x;
    simpa [ List.toFinset_card_of_nodup hnodup1, List.toFinset_card_of_nodup hnodup2 ] using Finset.card_lt_card h_proper_subset

/-
If a literal's variable is in the CNF, simplifying with that literal strictly reduces the number of variables.
-/
theorem simplify_length_lt (l : Literal) (cnf : CNF) (h : getVarsInLiteral l ∈ getVars cnf) :
  (getVars (simplify l cnf)).length < (getVars cnf).length := by
    apply length_lt_of_subset_of_mem_of_not_mem;
    any_goals assumption;
    · exact?;
    · -- The `eraseDup` function ensures that the resulting list has no duplicates.
      have h_eraseDup : ∀ l : List Nat, List.Nodup (l.eraseDup) := by
        intro l; induction l <;> simp_all +decide [ List.eraseDup ] ;
        unfold List.pwFilter; aesop;
      exact h_eraseDup _;
    · -- The list of variables in the CNF is constructed by taking the union of the variables in each clause, which are themselves lists of variables. Since the union of lists with no duplicates is also a list with no duplicates, the list of variables in the CNF is nodup.
      have h_nodup : ∀ (l : List Nat), List.Nodup (List.eraseDup l) := by
        intro l; induction l <;> simp_all +decide [ List.eraseDup ] ;
        unfold List.pwFilter; aesop;
      exact h_nodup _;
    · exact?

/-
If a literal `l` is in a clause `c` which is in the CNF `cnf`, then simplifying the CNF with `l` strictly reduces the number of variables.
-/
theorem solve_termination_helper (cnf : CNF) (c : Clause) (l : Literal) :
  c ∈ cnf → l ∈ c → (getVars (simplify l cnf)).length < (getVars cnf).length := by
    -- Since `l` is in `c`, and `c` is in `cnf`, the variable of `l` is in `cnf`. Therefore, we can apply the theorem `simplify_length_lt`.
    intros hc hl
    apply simplify_length_lt;
    exact getVars_contains_all_vars cnf _ ⟨ _, hc, _, hl, rfl ⟩

/-
The variable of a literal is the same as the variable of its negation.
-/
theorem getVarsInLiteral_negate (l : Literal) :
  getVarsInLiteral (negateLiteral l) = getVarsInLiteral l := by
    cases l <;> rfl

/-
Termination helper for the first recursive call in `solve`.
-/
theorem solve_termination_1 (cnf : CNF) (c : Clause) (cs : List Clause) (l : Literal) (ls : List Literal) (h_cnf : cnf = (l :: ls) :: cs) :
  (getVars (simplify l cnf)).length < (getVars cnf).length := by
    apply solve_termination_helper;
    -- The first clause of the CNF is (l :: ls) :: cs, which is clearly in the CNF.
    simp [h_cnf];
    exact Or.inl rfl;
    exact List.mem_cons_self

/-
Termination helper for the second recursive call in `solve`.
-/
theorem solve_termination_2 (cnf : CNF) (c : Clause) (cs : List Clause) (l : Literal) (ls : List Literal) (h_cnf : cnf = (l :: ls) :: cs) :
  (getVars (simplify (negateLiteral l) cnf)).length < (getVars cnf).length := by
    -- By definition of `getVars`, `negateLiteral l` is in `getVars cnf`.
    have h_neg_l_in_cnf : getVarsInLiteral (negateLiteral l) ∈ getVars cnf := by
      have h_neg_l_in_cnf : getVarsInLiteral l ∈ getVars cnf := by
        have h_l_in_c : l ∈ (l :: ls) := by
          simp
        apply getVars_contains_all_vars; aesop;
      rwa [ getVarsInLiteral_negate ];
    exact?

/-
The `solve` function checks if a CNF is satisfiable. If the CNF is empty, it's satisfiable. If it contains an empty clause, it's unsatisfiable. Otherwise, it picks a literal `l`, simplifies the CNF assuming `l` is true, and recursively solves. If that fails, it tries assuming `l` is false. Termination is guaranteed because the number of variables decreases.
-/
def solve (cnf : CNF) : Bool :=
  if cnf.isEmpty then true
  else if cnf.any List.isEmpty then false
  else
    match h : cnf with
    | [] => true
    | (c :: cs) =>
      match c with
      | [] => false
      | (l :: ls) =>
        solve (simplify l cnf) || solve (simplify (negateLiteral l) cnf)
termination_by (getVars cnf).length
decreasing_by
  simp_wf
  rw [← h]
  apply solve_termination_1 cnf (l :: ls) cs l ls h
  simp_wf
  rw [← h]
  apply solve_termination_2 cnf (l :: ls) cs l ls h

/-
The `solveSAT` function checks if a CNF is satisfiable. It returns true if the CNF is empty (satisfiable), false if it contains an empty clause (unsatisfiable). Otherwise, it picks a literal, simplifies the CNF assuming the literal is true, and recursively calls itself. If that fails, it tries assuming the literal is false. Termination is guaranteed by the decreasing number of variables.
-/
def solveSAT (cnf : CNF) : Bool :=
  if cnf.isEmpty then true
  else if cnf.any List.isEmpty then false
  else
    match h : cnf with
    | [] => true
    | (c :: cs) =>
      match c with
      | [] => false
      | (l :: ls) =>
        solveSAT (simplify l cnf) || solveSAT (simplify (negateLiteral l) cnf)
termination_by (getVars cnf).length
decreasing_by
  simp_wf
  rw [← h]
  apply solve_termination_1 cnf (l :: ls) cs l ls h
  simp_wf
  rw [← h]
  apply solve_termination_2 cnf (l :: ls) cs l ls h

/-
`update` modifies an assignment at a variable. `force` modifies an assignment to make a literal true. The theorem states that `force` indeed makes the literal true.
-/
def update (a : Assignment) (v : Nat) (b : Bool) : Assignment :=
  fun x => if x = v then b else a x

def force (a : Assignment) (l : Literal) : Assignment :=
  match l with
  | Literal.pos v => update a v true
  | Literal.neg v => update a v false

theorem evalLiteral_force (a : Assignment) (l : Literal) :
  evalLiteral (force a l) l = true := by
    unfold force;
    cases l <;> simp +decide [ evalLiteral, update ]

/-
If two assignments agree on all variables in a CNF, they evaluate the CNF to the same boolean value.
-/
theorem evalCNF_congr (a1 a2 : Assignment) (cnf : CNF) :
  (∀ v ∈ getVars cnf, a1 v = a2 v) → evalCNF a1 cnf = evalCNF a2 cnf := by
    intro h;
    -- By definition of `evalCNF`, it suffices to show that for every clause in `cnf`, the evaluation under `a1` and `a2` is the same.
    suffices hclause : ∀ c ∈ cnf, evalClause a1 c = evalClause a2 c by
      unfold evalCNF;
      grind;
    intro c hc
    have hclause_vars : ∀ l ∈ c, a1 (getVarsInLiteral l) = a2 (getVarsInLiteral l) := by
      exact fun l hl => h _ <| getVars_contains_all_vars _ _ ⟨ c, hc, l, hl, rfl ⟩;
    unfold evalClause;
    -- Since `evalLiteral a1 l` and `evalLiteral a2 l` are equal for all `l ∈ c`, the `any` function will return the same result for both assignments.
    have h_any_eq : ∀ l ∈ c, evalLiteral a1 l = evalLiteral a2 l := by
      intro l hl; specialize hclause_vars l hl; unfold evalLiteral; aesop;
    grind

/-
Forcing a literal `l` to true does not change the evaluation of `simplify l cnf`, because the simplified CNF does not contain the variable of `l`.
-/
theorem evalCNF_force_simplify (a : Assignment) (l : Literal) (cnf : CNF) :
  evalCNF (force a l) (simplify l cnf) = evalCNF a (simplify l cnf) := by
    convert evalCNF_congr _ _ _ _;
    intro v hv;
    unfold force;
    -- Since $v$ is in the simplified CNF, it must have been in the original CNF. Thus, $v$ is not equal to the variable of $l$.
    have hv_ne_var_l : v ≠ getVarsInLiteral l := by
      exact fun h => by have := simplify_removes_var l cnf; aesop;
    cases l <;> simp_all +decide [ update ];
    · exact?;
    · tauto

/-
If `solveSAT` returns true, then the CNF is satisfiable.
-/
theorem satisfiable_of_solveSAT_true (cnf : CNF) :
  solveSAT cnf = true → Satisfiable cnf := by
    unfold Satisfiable;
    -- By definition of `solveSAT`, if `solveSAT cnf` is true, then there exists an assignment `a` such that `evalCNF a cnf` is true.
    intro h_solveSAT
    induction' n : (getVars cnf).length using Nat.strong_induction_on with n ih generalizing cnf;
    unfold solveSAT at h_solveSAT;
    split_ifs at h_solveSAT;
    · cases cnf <;> tauto;
    · rcases cnf with ( _ | ⟨ c, cs ⟩ ) <;> simp_all +decide;
      rcases c with ( _ | ⟨ l, ls ⟩ ) <;> simp_all +decide;
      rcases h_solveSAT with ( h | h );
      · obtain ⟨ a, ha ⟩ := ih _ ( by
          rw [ ← n ];
          exact? ) _ h rfl;
        use force a l;
        -- By the properties of `force`, we know that `evalCNF (force a l) (simplify l ((l :: ls) :: cs))` is true.
        have h_force : evalCNF (force a l) (simplify l ((l :: ls) :: cs)) = Bool.true := by
          rw [ evalCNF_force_simplify ] ; aesop;
        -- By the properties of `simplify`, we know that `evalCNF (force a l) ((l :: ls) :: cs)` is true if and only if `evalCNF (force a l) (simplify l ((l :: ls) :: cs))` is true.
        have h_simplify : evalCNF (force a l) ((l :: ls) :: cs) ↔ evalCNF (force a l) (simplify l ((l :: ls) :: cs)) := by
          apply simplify_correct;
          exact?;
        exact h_simplify.mpr h_force;
      · -- By the induction hypothesis, there exists an assignment `a` such that `evalCNF a (simplify (negateLiteral l) ((l :: ls) :: cs))` is true.
        obtain ⟨a, ha⟩ : ∃ a : Assignment, evalCNF a (simplify (negateLiteral l) ((l :: ls) :: cs)) := by
          apply ih (getVars (simplify (negateLiteral l) ((l :: ls) :: cs))).length (by
          rw [ ← n ];
          apply solve_termination_2;
          exacts [ ls, rfl ]) (simplify (negateLiteral l) ((l :: ls) :: cs)) h rfl;
        use force a (negateLiteral l);
        unfold evalCNF at *;
        unfold simplify at ha;
        simp_all +decide [ List.all_eq, List.filterMap_eq_nil_iff ];
        unfold evalClause at *; simp_all +decide [ List.any_eq, List.filter_eq ] ;
        constructor;
        · contrapose! ha;
          use List.filter (fun x => x != l) (l :: ls);
          cases l <;> simp_all +decide [ evalLiteral ];
          · unfold force at ha; simp_all +decide [ negateLiteral ] ;
            unfold update at ha; simp_all +decide [ List.filter_eq ] ;
            constructor;
            · grind;
            · intro x hx hx'; specialize ha x hx; rcases x with ( _ | _ | x ) <;> simp_all +decide ;
          · unfold force at ha; simp_all +decide [ negateLiteral ] ;
            unfold update at ha; simp_all +decide ;
            constructor;
            · grind;
            · intro x hx hx'; specialize ha x hx; rcases x with ( _ | _ | x ) <;> simp_all +decide ;
        · intro c hc; specialize ha ( List.filter ( fun x => x != l ) c ) ; simp_all +decide [ List.filter_eq ] ;
          contrapose! ha;
          refine' ⟨ Or.inr ⟨ c, hc, _, _ ⟩, _ ⟩;
          · exact fun h => ha _ h <| by unfold evalLiteral; unfold force; unfold update; aesop;
          · cases l <;> aesop;
          · intro x hx; specialize ha x hx.1; unfold force at ha; simp_all +decide [ evalLiteral ] ;
            cases x <;> cases l <;> simp_all +decide [ update ];
            · unfold negateLiteral at ha; simp_all +decide [ update ] ;
            · unfold negateLiteral at ha; simp_all +decide [ update ] ;
            · unfold negateLiteral at ha; simp_all +decide [ update ] ;
            · unfold negateLiteral at ha; simp_all +decide [ update ] ;

/-
If a CNF is satisfied by an assignment `a` and a literal `l` is true under `a`, then `simplify l cnf` is satisfiable (by `a`).
-/
theorem satisfiable_simplify_of_satisfiable (cnf : CNF) (l : Literal) (a : Assignment) :
  evalCNF a cnf → evalLiteral a l → Satisfiable (simplify l cnf) := by
    intro h1 h2;
    have := simplify_correct l cnf a h2;
    exact ⟨ a, by simpa [ h1 ] using this.mp h1 ⟩

/-
If a CNF is satisfied by an assignment `a` and a literal `l` is false under `a`, then `simplify (negateLiteral l) cnf` is satisfiable (by `a`).
-/
theorem satisfiable_simplify_negate_of_satisfiable (cnf : CNF) (l : Literal) (a : Assignment) :
  evalCNF a cnf → evalLiteral a l = false → Satisfiable (simplify (negateLiteral l) cnf) := by
    -- By definition of `solveSAT`, if `solveSAT cnf = Bool.true`, then `cnf` is satisfiable.
    intros h_evalCNF h_evalLiteral
    apply satisfiable_simplify_of_satisfiable;
    exact h_evalCNF;
    unfold evalLiteral at *;
    unfold negateLiteral; aesop;

/-
If the CNF is satisfiable, then `solveSAT` returns true. This is proved by induction on the number of variables. If the CNF is empty, it's true. If it has an empty clause, it's unsatisfiable (contradiction). Otherwise, we pick a literal `l`. If `l` is true in the satisfying assignment, we recurse on `simplify l cnf`. If `l` is false, we recurse on `simplify (negateLiteral l) cnf`.
-/
theorem solveSAT_true_of_satisfiable (cnf : CNF) :
  Satisfiable cnf → solveSAT cnf = true := by
    induction' n : ( getVars cnf ).length using Nat.strong_induction_on with k ih generalizing cnf;
    unfold solveSAT;
    intro h;
    rcases cnf with ( _ | ⟨ c, _ | ⟨ cs, cnf ⟩ ⟩ ) <;> simp_all +decide;
    · rcases c with ( _ | ⟨ l, _ | ⟨ ls, c ⟩ ⟩ ) <;> simp_all +decide;
      · obtain ⟨ a, ha ⟩ := h;
        cases ha;
      · obtain ⟨ a, ha ⟩ := h;
        -- Since `l` is true under `a`, `simplify l [[l]]` will remove the clause `[l]` from the CNF.
        have h_simplify_l : simplify l [[l]] = [] := by
          unfold simplify; aesop;
        unfold solveSAT; aesop;
      · obtain ⟨ a, ha ⟩ := h;
        by_cases h : evalLiteral a l <;> simp_all +decide [ evalCNF ];
        · -- Since `l` is true in `a`, `simplify l cnf` is satisfiable by `a`.
          have h_simplify_l : Satisfiable (simplify l [l :: ls :: c]) := by
            apply satisfiable_simplify_of_satisfiable;
            rotate_right;
            exact a;
            · unfold evalCNF; aesop;
            · assumption;
          refine Or.inl <| ih _ ?_ _ rfl h_simplify_l;
          rw [ ← n ];
          apply solve_termination_1;
          exact l :: ls :: c;
          rotate_left;
          exacts [ [ ], ls :: c, rfl ];
        · -- Since `l` is false under `a`, we can apply the induction hypothesis to `simplify (negateLiteral l) [l :: ls :: c]`.
          have h_ind : Satisfiable (simplify (negateLiteral l) [l :: ls :: c]) := by
            have h_ind : evalCNF a [l :: ls :: c] := by
              unfold evalCNF; aesop;
            exact?;
          refine Or.inr <| ih _ ?_ _ rfl h_ind;
          rw [ ← n ];
          exact?;
    · rcases c with ( _ | ⟨ l, ls ⟩ ) <;> rcases cs with ( _ | ⟨ m, ms ⟩ ) <;> simp_all +decide;
      · obtain ⟨ a, ha ⟩ := h;
        cases ha;
      · obtain ⟨ a, ha ⟩ := h;
        simp_all +decide [ evalCNF ];
        unfold evalClause at ha; aesop;
      · obtain ⟨ a, ha ⟩ := h;
        simp_all +decide [ evalCNF ];
        unfold evalClause at ha; aesop;
      · obtain ⟨ a, ha ⟩ := h;
        by_cases h : evalLiteral a l <;> simp_all +decide [ evalCNF ];
        · have h_simp : Satisfiable (simplify l ((l :: ls) :: (m :: ms) :: cnf)) := by
            apply satisfiable_simplify_of_satisfiable;
            rotate_right;
            exact a;
            · unfold evalCNF; aesop;
            · assumption;
          have h_simp : (getVars (simplify l ((l :: ls) :: (m :: ms) :: cnf))).length < k := by
            rw [ ← n ];
            apply solve_termination_helper;
            exacts [ List.mem_cons_self, List.mem_cons_self ];
          exact ⟨ fun h => by have := ha.2.2 _ h; simp_all +decide [ evalClause ], Or.inl <| ih _ h_simp _ rfl ‹_› ⟩;
        · have h_simplify_negate : Satisfiable (simplify (negateLiteral l) ((l :: ls) :: (m :: ms) :: cnf)) := by
            apply satisfiable_simplify_negate_of_satisfiable;
            rotate_right;
            exact a;
            · unfold evalCNF; aesop;
            · exact h;
          have h_simplify_negate_length : (getVars (simplify (negateLiteral l) ((l :: ls) :: (m :: ms) :: cnf))).length < k := by
            rw [ ← n ];
            exact?;
          exact ⟨ fun h => by have := ha.2.2 _ h; simp_all +decide [ evalClause ], Or.inr <| ih _ h_simplify_negate_length _ rfl h_simplify_negate ⟩

/-
If a CNF is satisfiable, it contains no empty clauses.
-/
theorem not_any_isEmpty_of_satisfiable (cnf : CNF) :
  Satisfiable cnf → cnf.any List.isEmpty = false := by
    rintro ⟨ a, ha ⟩;
    contrapose! ha; simp_all +decide [ evalCNF ];
    exact ⟨ _, ha, by unfold evalClause; aesop ⟩

/-
If the CNF is satisfiable, then `solveSAT` returns true. This is proved by induction on the number of variables. If the CNF is empty, it's true. If it has an empty clause, it's unsatisfiable (contradiction). Otherwise, we pick a literal `l`. If `l` is true in the satisfying assignment, we recurse on `simplify l cnf`. If `l` is false, we recurse on `simplify (negateLiteral l) cnf`.
-/
theorem solveSAT_complete (cnf : CNF) :
  Satisfiable cnf → solveSAT cnf = true := by
    exact?

/-
Completeness of `solveSAT`: if the CNF is satisfiable, `solveSAT` returns true. We use strong induction on the number of variables. The base cases (empty CNF, empty clause) are handled by the definition of `solveSAT` and the fact that a satisfiable CNF cannot contain an empty clause. For the recursive step, we use the fact that if the CNF is satisfiable, then either `simplify l cnf` or `simplify (negateLiteral l) cnf` is satisfiable, depending on the truth value of `l` in the satisfying assignment. We then apply the induction hypothesis.
-/
theorem solveSAT_complete_proof (cnf : CNF) :
  Satisfiable cnf → solveSAT cnf = true := by
    exact?

/-
The `solveSAT` function is correct: it returns true if and only if the CNF is satisfiable. This follows from the soundness and completeness theorems.
-/
theorem solveSAT_correct (cnf : CNF) :
  solveSAT cnf = true ↔ Satisfiable cnf := by
  constructor
  · apply satisfiable_of_solveSAT_true
  · apply solveSAT_complete
